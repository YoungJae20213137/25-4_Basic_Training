# CTF

25-4 CTF 개념 정리 - 네트워크

## 네트워크

### 1번 문제

**wireshark에서 자주 쓰는 기능 3가지**

1. 필터링: 프로토콜 / ip 주소 / 포트 등 원하는 패킷만 필터링해서 보여주는 기능
     - 프로토콜 기반: tcp / udp / http / icmp
     - ip 기반 : ip.addr == 192.168.0.1
     - 문자열 기반 : ftp contains "hello" -> hello 들어간 ftp 프로토콜 필터링
     - 연산자 : AND(&&), OR(||), NOT(!)

2. 따라가기(follow) 기능
     가장 자주쓰는 기능 중 하나로, 스트림을 쉽게 읽을 수 있는 형태로 재조립해서 데이터를 정렬해서 보여주는 기능이다.

3. 객체 내보내기 기능 (Export Object)
       프로토콜에서 발생한 패킷 내의 파일들을 보고, 추출할 수 있는 기능
   
       ex) http 형태의 스크립트 악성코드가 다운받아졌다. / SMB 프로토콜로 악성파일이 주고 받아졌다.

5. TCP 스트림 따라가기 입력 내용에 따른 색 차이
   
    파란색: 서버
   
    빨간색: 사용자

***

### 2번 문제

**힌트**
1. PNG 파일
2. XOR 연산


파일 시그니처 : 각 파일마다 고유하게 정해진 바이트 패턴 (헤더 / 풋터)

     EX) JPG 파일 : FF D8 FF E0
         PNG 파일 : 89 50 4E 47 0D 0A 1A 0A
          - 포렌식, 악성코드 분석, 파일 복구 등에서 파일의 정확한 종류와 변조여부 확인

XOR(베타적 논리합) : 두 비트가 같으면 0, 다르면 1을 반환하는 비트연산

- 암호화 기법에서 가장 기본이 되며 널리 사용되는 연산 XOR
          
- XOR의 특징 중 암호화와 복호화가 동일하기 때문에 아래와 같은 성질이 성립 (자기 역원성 (self-inverse) 특성)



A XOR B = C 일 때 / C XOR B = A / C XOR A = B

```
정상 map.png 시그니처 값 (XOR) KEY = ????????

= 암호화된 map.png 시그니처 값
```
```
정상 map.png 시그니처 (XOR) 변조된 map.png 시그니처

= 우리가 찾는 KEY 값
```
***

### 3번 문제

**힌트**
1. icmp ping scan
2. length 차이


Base64 디코딩

***

### 4번 문제

**힌트: telnet 패킷 분석**

wireshark에서 telnet 패킷만 찾는 필터

```
tcp.port == 23
```

***

### 5번 문제

**힌트: SMB 프로토콜**

SMB 프로토콜 요약:
파일 공유 및 프린터 공유, 네트워크 리소스 탐색을 위한 프로토콜.

주로 Windows 시스템 간의 파일 공유에 사용되며, Linux와 macOS에서 Samba를 통해 지원.

최신 버전인 SMB 3.0 이상은 보안 및 성능 최적화가 크게 향상됨.

SMB 1.0은 보안 취약점이 많아 사용하지 않거나 비활성화하는 것이 권장됨.

***

### 6번 문제

FTP 응답 코드: 230
230: User logged in, proceed

이 응답 코드는 사용자가 성공적으로 로그인한 후에 서버가 보내는 메시지입니다. 사용자가 로그인 자격증명을 정확히 입력하고 인증이 완료되었음을 의미합니다.

wireshark에서 필터 사용법
```
필터: ftp.response.code == 230
ftp.response.code: FTP 응답 코드 필드를 기준으로 필터링합니다.

230: 성공적인 로그인 응답 코드입니다.
```

***

### 7번 문제

1. HTTP DOS 공격 (Slow http Header Dos / SlowLoris 공격)

- 정상적인 http 연결처럼 보이게끔 하는 패턴으로, 웹 서버의 자원을 고갈시키는 공격 (cr, If)
- 적은 트래픽으로 공격이 가능
- 공격자는 다수의 http 연결을 동시에 열고, 각 연결에 대해 http 헤더를 불완전하게, 천천히 전송, 서버는 요청이 끝나지 않은 것으로 판단하여, 가용량이 모두 떨어지게 됨.

통계에서 I/O 그래프 클릭 후, 시간 당 패킷량이 가장 높이 튀는 지점을 클릭하여, 패킷을 따라가보면 정답을 찾을 수 있음.

***

### 8번 문제

SQL Injection: 클라이언트가 웹 서버에 요청을 하는 과정에서 입력 값 검증을 제대로 하지 않아, DB에 사용자가 입력한 SQL문이 전달되는 취약점 (DB 정보 유출, DB 구조 파악 등)

Union SQL Injection: 두 개의 SQL 문을 결합해서 만드는 SQL 공격

- 보통 정상질의 뒤에 (U) 다른 악성질의를 결합해서 SQL문을 주입

SUBSTR 함수 : 문자열에서 특정 위치부터, 지정된 길이만큼 부분 문자열(서브 스트링)을 추출하는 함수

- SQL, 오라클 등에서의 기본 구조

```
SUBSTR(문자열, 시작위치, 길이)
```

```
EX) SUBSTR("HELLO WORLD", 7, 5) => 7번째 문자부터 5글자 추출
=> WORLD
* 시작 인덱스는 1
```
```
EX) SUBSTR("HELLO WORLD", 1, 4) => 1번째 문자부터 4글자 추출
=> HELL
```

cf) php등 일부 언어에서 인덱스가 0부터 시작하기도 하지만 우리와는 관련 X

핵심: http 패킷 객체 내보내기 해서 %3d -> = 등호 문자 찾아서 플래그 값 알아내기

powershell에서 정수 값을 ASCII 코드에 해당하는 문자로 변환하는 방법
```
[char][int] 숫자
```
```
EX) [char][int] 100
=> d
```

***

### 9번 문제

**SSL 암호화란?**

SSL 암호화는 인터넷 상에서 데이터를 보호하고 안전하게 전송할 수 있게 해주는 프로토콜입니다.

공개키 암호화와 대칭키 암호화를 결합하여 기밀성, 무결성, 인증을 제공합니다.

현재 SSL은 보안 취약점이 있어, 대부분 TLS로 대체되었지만 여전히 많은 사람들이 SSL이라는 용어를 사용합니다.

**힌트**
1. SSL 통신 평문으로 복호화 필요

  - FTP 패킷 중에서, 오고간 파일들 중에서, SSL 복호화 키(.pem) 찾기
  - 편집 - 설정 - protocols - TLS - 편집 - 복호화 키 파일 등록

2. 복호화된 패킷에서 암호화된 패스워드 획득

3-1. login.php 파일 내 decrypt_pw 함수 스크립트를 참고하여 복호화 스크립트 작성

3-2. 인터넷 검색 : AES 복호화 (암호문자열, key)

**pem 파일이란?**

.pem 파일은 Base64 인코딩된 텍스트 형식으로 SSL/TLS 인증서, 공개 키, 개인 키, CSR(인증서 서명 요청) 등을 저장하는 파일입니다.

.pem 형식은 주로 웹 서버나 SSH 연결에서 사용되며, 암호화된 통신을 설정하는 데 중요한 역할을 합니다.

텍스트 기반이기 때문에, 인증서와 키를 손쉽게 관리하고 검토할 수 있습니다.

```
ftp.request.command == RETR
```

RETR: FTP 프로토콜로 통신 중, 클라이언트가 서버로부터 특정 파일을 다운로드하고자 할 때, 사용되는 명령이다.

wireshark에서 위 필터를 사용하면, FTP 프로토콜에서 파일 다운로드 요청을 나타내는 RETR 명령을 포함한 패킷을 Wireshark에서 추출하는 데 사용됩니다. 이를 통해 FTP 다운로드 트래픽을 확인하거나 분석할 수 있습니다.

**ftp와 ftp-data의 차이?**

FTP는 제어 연결 (Control Connection) 을 의미하며, 파일 전송에 대한 명령어와 응답을 처리합니다. 포트 21을 사용합니다.

FTP-DATA는 실제 파일 전송을 위한 데이터 연결 (Data Connection) 을 의미하며, 파일의 내용을 실제로 주고받습니다. 포트 20 또는 임의의 포트를 사용합니다.

Wireshark에서 ftp는 제어 연결을, ftp.data는 데이터 전송을 나타냅니다.

**PHP 파일이란?**

PHP 파일은 PHP 코드가 포함된 웹 페이지를 생성하기 위한 서버 사이드 스크립트 파일입니다.

PHP는 동적 웹 페이지 생성, 데이터베이스 처리, 폼 처리, 파일 업로드/다운로드 등 다양한 웹 기능을 처리할 수 있습니다.

웹 서버는 PHP 파일을 실행하고, 결과를 HTML로 변환하여 클라이언트에게 전달합니다.

**PHP-HTML파일 참조하기**

PHP와 HTML을 섞어서 사용: PHP 파일 내에 HTML 코드를 직접 삽입하여 동적으로 콘텐츠를 생성할 수 있습니다.

HTML 파일 포함하기: include 또는 require를 사용해 HTML 파일을 PHP 파일 내에서 포함하여 재사용할 수 있습니다.

동적 HTML 생성: PHP 코드로 데이터를 처리하고, 동적으로 HTML을 생성하여 웹 페이지에 출력할 수 있습니다.

외부 HTML 가져오기: file_get_contents나 cURL을 사용하여 외부 HTML 파일을 가져오고 표시할 수 있습니다.

***

### 10번 문제

**권한 상승(PE)이란?**

PE 공격 (Privilege Escalation)은 공격자가 시스템에서 자신의 권한을 상승시켜 더 높은 수준의 권한을 얻는 공격 기법입니다.

권한 상승 공격은 로컬 및 원격 방식으로 발생할 수 있으며, 취약한 파일 권한, 소프트웨어 버그, 잘못된 시스템 설정 등을 악용합니다.

이를 방어하려면 정기적인 보안 패치, 최소 권한 원칙 적용, 파일 및 디렉토리 권한 설정 강화 등의 보안 정책을 취해야 합니다.


wireshark에서 특정 문자열 잡는 필터
```
EX) tcp contains program

=> TCP 패킷 내에서 "program" 문자열을 포함하는 패킷만 화면에 띄워줘.
```

1) 공격자는 PE 악성코드를 통해 먼저 공격하였습니다.

   - PE 시그니처 : Program, DOS, MZ 등

   - 필터링 : ```tcp contains "program"``` // 악성코드가 다운로드된 사이트 확인
  
2) 해당 사이트로부터 오고 간 의심스러운 파일 분석 후 답 찾아보기

company.htm (문제와 무관, 다운로드 X)

- 실제 시스템 로그 수집하는 악성코드 (mimikatz)

***

<br>

## 악성코드

### 1번 문제

**PE 파일 구조**

PE(Portable Executable) 파일 : 윈도우 운영체제의 실행파일 형식

```
실행 계열: EXE, SCR
드라이버 계열: SYS, VXD
라이브러리 계열 : DLL, OCX, CPL, DRV
오브젝트 계열 : OBJ
```

DOS 헤더 시그니처: 0x4D 0x5A (ASCII: "MZ")

PE 파일 기본 구조는 크게 PE 헤더와 바디(섹션)로 구성된다.

<img width="451" height="392" alt="화면 캡처 2025-08-06 102640" src="https://github.com/user-attachments/assets/4e5b60b1-7ffd-4f87-86e7-c6f196972274" />

**ImageBase(기준점)**
- PE 파일이 메모리에 로딩될 때의 기본 주소 값
- 가상 메모리에서의 PE 파일이 로딩되는 주소, 일반적으로 EXE 파일의 값은 0x00400000
- DLL의 경우 0x01000000
- 실행 시 코드와 데이터가 이 주소부터 시작된다고 가정하고 작성됨

**Address of EntryPoint**
- 실행이 시작되는 진입점 함수의 RVA (Relative Virtual Address)
- 운영체제가 실행 시 이 주소를 찾아 코드 실행을 시작함

**Start of TextSection**
-.text 섹션(즉, 실행 코드)의 시작 위치
- 보통 바이너리에서 기계어 코드가 위치하는 첫 주소

**x32dbg(디버거)**

(문자열 참조 기능)

**자주 쓰는 조합**
- f2 : breakpoint
- Ctrl + f2 : 다시 시작
- f9 : entrypoint 진입

**그 외 기능**
- f7 : 하나의 OP code 실행 (함수 내부로 진입 // 안으로 단계 진행)
- f8 : 하나의 OP code 실행 (함수만 실행 // 건너서 단계 진행 (스텝 오버))
- Ctrl + G : 원하는 주소로 이동 (해당 주소까지 실행되지는 않음)
- Ctrl + E : 데이터 편집

문제에서, 

ImageBase(기준점): 0x 00400000

AddressOfEntryPoint: 0x 0040126F (실제 주소), 0x 0000126F (상대 주소)

StartOfTextSection:  0x 00401000 (실제 주소), 0x 00001000 (상대 주소)

가상 주소는 얼마만큼 떨어져있는지를 표시.

***

### 2번 문제

```
add eax, 1
mov dword ptr ss:[ebp-8], eax
cmp dword ptr ss:[ebp-8], 4
jge 002.401081
```
=> 1씩 증가하며 4번의 반복 과정

```
add ecx, 1
mov dword ptr ss:[ebp-4], ecx
cmp dword ptr ss:[ebp-4], 8
jge 002.40107F
```
=> 1씩 증가하며 8번의 반복 과정

```
movsx ecx, byte ptr ds:[eax+edx*4+41E000]
```
=> 41E000 주소와 데이터를 반복 과정에서 사용되는 레지스터와 함께 연산해 한글자씩 가져옴

```
cmp edx, dword ptr ss:[ebp-14]
je 002.40107D
```
=> 가져온 글자와 사용자의 입력을 한 글자씩 비교

분석된 정보를 바탕으로 Python Script 작성
```
j = 0
i = 0

a = "분석된 String"

for j in range(4):
     for i in range(8):
          print(a[i*4+j], end='')
```

***

### 3번 문제

dropper.doc : 문서형 악성코드

악성코드가 흔히, vbaproject.bin 바이너리 파일에 저장 (공격자는 여기에 악성 VBA 스크립트(= 매크로)를 집어넣어, 사용자가 문서를 열 때 자동으로 악성 행위를 수행하도록 만들 수 있음.)

***

### 4번 문제

패킹: 실행 파일 크기를 줄이고, 실행 파일 내부를 분석하기 어렵게 만듦.

UPX는 그 중 가장 널리 사용되는 오픈 소스 패킹 툴

1. 파일 크기 감소: 프로그램을 컴팩트하게 만들어 배포나 네트워크 전송을 효율적으로 함.
2. 코드 보호/보안: 리버스 엔지니어링, 디버깅, 디스어셈블링을 어렵게 하여 소스 분석 방지(특히 악성코드에서 많이 사용)
3. 데이터 보호: 주요 기능, 라이선스 인증, 민감 정보 노출 최소화
4. 실행 파일 내부 구조 변경: 원본 코드, 데이터, 리소스를 숨기거나 섹션 이름 변경 등.

<어셈블리 명령어>

pushad: EAX~EDI 등 주요 레지스터 값을 스택에 저장(백업)

popad: 스택의 값을 원래 레지스터로 복구

popad 이후 JMP가 원본 코드(OEP)로 이동 -> **리버스 엔지니어링에서 중요한 단서**

***

## 포렌식

### 1번 문제

1) volatility_2.6_win64_standalone.exe -f mem.raw imageinfo - 분석에 적합한 프로필 확인
2) volatility_2.6_win64_standalone.exe -f mem.raw --profile=Win7SP1x64 filescan >> filescan.txt - 메모리상에 존재하는 파일 목록 확인 후 filescan.txt로 저장
3) filescan.txt에서 사용자가 보고 있던 사진 확인
4) volatility_2.6_win64_standalone.exe -f mem.raw --profile=Win7SP1x64 dumpfiles -Q 메모리주소값 -D ./ - 특정 메모리주소값(오프셋)에 존재하는 파일을 추출 후, 복원(경로 지정)

***

### 2번 문제

**부팅과정**

1) BIOS가 MBR을 로드
2) MBR 부트 코드는 부팅 가능한 파티션을 찾아, 해당 파티션의 첫 섹터에 위치한 VBR을 실행
3) MBR 코드는 운영체제 커널 파일을 찾아 로드

운영 체제가 로드될 때 읽는 드라이브의 첫 번째 섹터 : MBR(Master Boot Record): 512바이트

MBR - Partition Table Entry(0x01BE - 0x01FD) (시작했을 때의 위치)

파티션 테이블은 총 64 바이트로 이루어져 있음.

16바이트씩 총 4개의 파티션을 생성 가능.

```
- 1번째 바이트: 부팅 가능 여부(부트플래그) 0x80(부팅가능) / 0x00(부팅불가)
- 2~4번째 바이트: CHS 주소지정방식의 파티션 시작 위치
(CHS는 8바이트 이하 디스크에서만 유효, 현대 시스템에서는 LBA 방식을 사용, 무시 가능)
- 5번째 바이트: 파티션의 유형 (NTFS의 경우 07, FAT의 경우 0C)
- 6~8번째 바이트: CHS 주소지정 방식의 파티션의 끝 위치
- 9~12번째 바이트: LBA 주소 지정방식의 시작 위치: LBA 시작주소 - 해당 섹터로 이동해 확인 0x80(128번째 섹터)
- 13~16번째 바이트: 저장장치의 섹터 수(한 섹터는 512 byte)
```

MBR 시그니처 = 55 AA (2 byte)

**MBR Table**

C 드라이브에 대한 정보

00 02 03 00 07 61 1B 06 **80 00 00 00** **00 90 01 00** = BOLD표시는 의미 있는 정보

0x80 = 128 (C 드라이브의 시작 주소 섹터)

0x19000 = 102,400 (C 드라이브의 전체 중 섹터)

= 102,528

백업본은 마지막 섹터의 바로 앞 섹터에 위치 = 102,527

***

### 3번 문제

FTK Imager에서 삭제된 파일은 아이콘에 X표시 되어 있음.

마우스 우클릭 -> Export Files -> 경로 지정 -> 확인

***

